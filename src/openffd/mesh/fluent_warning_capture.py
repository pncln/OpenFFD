"""
Specialized warning capture system for Fluent meshes.

This module provides functionality to intercept and process warnings generated by meshio
when reading Fluent mesh files, particularly zone specifications not natively supported.
"""

import re
import sys
import warnings
import logging
from io import StringIO
from typing import List, Tuple, Dict, Optional, Set
from enum import Enum, auto

# Configure logging
logger = logging.getLogger(__name__)

class ZoneType(Enum):
    """Types of zones in Fluent meshes."""
    VOLUME = auto()
    BOUNDARY = auto()
    INTERFACE = auto()
    UNKNOWN = auto()

class CapturedZone:
    """A captured zone specification from a warning message."""
    
    def __init__(self, zone_type: str, zone_name: str):
        """Initialize a CapturedZone object.
        
        Args:
            zone_type: Type of zone (e.g., 'wall', 'fluid', 'interior')
            zone_name: Name of the zone
        """
        self.zone_type = zone_type.strip().lower()
        self.zone_name = zone_name.strip()
        self.sanitized_name = self._sanitize_name()
        self.enum_type = self._determine_enum_type()
    
    def _sanitize_name(self) -> str:
        """Create a sanitized zone name suitable for use as an identifier.
        
        Returns:
            Sanitized zone name
        """
        # Replace spaces and special characters with underscores
        sanitized = re.sub(r'[\s-]', '_', self.zone_name)
        
        # Combine type and name if they're different
        if self.zone_type != sanitized:
            return f"{self.zone_type}_{sanitized}"
        return sanitized
    
    def _determine_enum_type(self) -> ZoneType:
        """Determine the zone type enum based on the string type.
        
        Returns:
            ZoneType enum value
        """
        if self.zone_type in ['interior', 'fluid']:
            return ZoneType.VOLUME
        elif self.zone_type in ['wall', 'symmetry', 'pressure-outlet', 'velocity-inlet', 
                              'pressure-inlet', 'mass-flow-inlet', 'axis']:
            return ZoneType.BOUNDARY
        elif self.zone_type in ['interface', 'periodic', 'fan', 'porous-jump', 'non-conformal-interface']:
            return ZoneType.INTERFACE
        else:
            return ZoneType.UNKNOWN
    
    def __str__(self) -> str:
        """String representation of the captured zone."""
        return f"Zone: {self.sanitized_name} (Type: {self.zone_type}, {self.enum_type.name})"


# Global variable to store captured zones
captured_zones = []


def reset_captured_zones() -> None:
    """Reset the captured zones to an empty list."""
    global captured_zones
    captured_zones = []


def capture_warning(message, category, filename, lineno, file=None, line=None) -> None:
    """Custom warning handler that captures zone specifications from meshio warnings.
    
    This captures warnings like: "Zone specification not supported yet (wall, launchpad). Skipping."
    
    Args:
        message: Warning message
        category: Warning category
        filename: Source filename
        lineno: Line number
        file: File object
        line: Line content
    """
    global captured_zones
    msg_str = str(message)
    
    # Check if this is a zone specification warning
    if "Zone specification not supported yet" in msg_str:
        # Extract zone type and name from the warning message
        match = re.search(r'\(([^,]+),\s*([^)]+)\)', msg_str)
        if match:
            zone_type = match.group(1)
            zone_name = match.group(2)
            
            # Create captured zone
            zone = CapturedZone(zone_type, zone_name)
            captured_zones.append(zone)
            logger.info(f"Captured zone: {zone}")
    
    # Call the original warning handler
    original_showwarning(message, category, filename, lineno, file, line)


class WarningCapture:
    """Context manager for capturing warnings."""
    
    def __init__(self):
        """Initialize the warning capture."""
        self.original_showwarning = None
    
    def __enter__(self):
        """Start capturing warnings."""
        global original_showwarning
        reset_captured_zones()
        self.original_showwarning = warnings.showwarning
        original_showwarning = self.original_showwarning
        warnings.showwarning = capture_warning
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        """Stop capturing warnings."""
        warnings.showwarning = self.original_showwarning
        logger.info(f"Captured {len(captured_zones)} zone specifications")


def get_captured_zones() -> List[Tuple[str, str, ZoneType]]:
    """Get the captured zones as tuples.
    
    Returns:
        List of tuples (zone_type, zone_name, zone_enum_type)
    """
    return [(zone.zone_type, zone.sanitized_name, zone.enum_type) for zone in captured_zones]


def capture_warnings_from_command(command_func, *args, **kwargs) -> List[Tuple[str, str, ZoneType]]:
    """Execute a command and capture warnings to extract zone specifications.
    
    Args:
        command_func: Function to execute
        *args: Arguments to pass to the function
        **kwargs: Keyword arguments to pass to the function
        
    Returns:
        List of tuples (zone_type, zone_name, zone_enum_type)
    """
    with WarningCapture():
        # Execute the command
        result = command_func(*args, **kwargs)
    
    # Return the captured zones
    return get_captured_zones()


def capture_zones_from_mesh_loading(mesh_file: str) -> List[Tuple[str, str, ZoneType]]:
    """Load a mesh file and capture zone specifications from warnings.
    
    Args:
        mesh_file: Path to the mesh file
        
    Returns:
        List of tuples (zone_type, zone_name, zone_enum_type)
    """
    try:
        import meshio
        
        with WarningCapture():
            # Attempt to read the mesh file, which will generate warnings
            mesh = meshio.read(mesh_file)
        
        # Return the captured zones
        return get_captured_zones()
    
    except Exception as e:
        logger.error(f"Error loading mesh with meshio: {e}")
        return []
